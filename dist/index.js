!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.primalityTest=n():e.primalityTest=n()}(this,(()=>(()=>{"use strict";var e={d:(n,t)=>{for(var r in t)e.o(t,r)&&!e.o(n,r)&&Object.defineProperty(n,r,{enumerable:!0,get:t[r]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},n={};e.r(n),e.d(n,{primalityTest:()=>w});const t=0n,r=1n;function i(e){return e.toString(2).length}function o(e,n){if(e===n)return e;if(e===t)return n;if(n===t)return e;let i=t;for(;!(e&r|n&r);)i++,e>>=r,n>>=r;for(;e!==n&&n>r;){for(;!(e&r);)e>>=r;for(;!(n&r);)n>>=r;if(n>e)[e,n]=[n,e];else if(e===n)break;e-=n}return n<<i}function l(e){let n="";for(;n.length<e;)n+=Math.random().toString(2).substring(2,50);return n.substring(0,e)}const s=0n,u=1n;function f(e){if(!(e&u))throw new Error("base must be odd");const n=i(e),t=BigInt(n),o=u<<t,l=function(e,n){let t=r;for(let i=0;i<e;i++)t&r&&(t+=n),t>>=r;return t}(n,e);return{base:e,shift:t,r:o,rInv:l,baseInv:o-(l*o-u)/e%o}}function a(e,n){return(e<<n.shift)%n.base}function b(e,n){return e*n.rInv%n.base}function c(e,n){return d(e,e,n)%n.base}function d(e,n,t){if(e===s||n===s)return s;const r=t.r-u;let i=e*n;let o=i-((i&r)*t.baseInv&r)*t.base>>t.shift;return o>=t.base?o-=t.base:o<s&&(o+=t.base),o}function p(e,n,t){const r=BigInt(i(n));let o=a(u,t);for(let i=s,l=e;i<r;++i,l=c(l,t))n&u<<i&&(o=d(o,l,t));return o}class PrimalityResult{constructor({n:e,probablePrime:n,witness:t=null,divisor:r=null}){this.n=e,this.probablePrime=n,this.witness=t,this.divisor=r}}const m=0n,y=1n,g=2n,v=4n,h=-1n;function w(e,{numRounds:n,bases:s,findDivisor:u=!0}={}){return new Promise(((d,w)=>{try{"bigint"!=typeof e&&(e=BigInt(e));const w=e<m?h:y;if(w===h&&(e=-e),e<g)return void d(new PrimalityResult({n:w*e,probablePrime:!1,witness:null,divisor:null}));if(e<v)return void d(new PrimalityResult({n:w*e,probablePrime:!0,witness:null,divisor:null}));if(!(e&y))return void d(new PrimalityResult({n:w*e,probablePrime:!1,witness:null,divisor:g}));const I=i(e),j=e-y,R=function(e){if(e===t)return t;let n=t;for(;;){if(e&r<<n)return n;n++}}(j),S=j>>R,T=f(e),k=a(y,T),B=a(j,T),O=function(e,n){if(null==e)return null;if(Array.isArray(e))return e.map((e=>{if("bigint"!=typeof e&&(e=BigInt(e)),!(e>=g&&e<n))throw new RangeError(`invalid base (must be in the range [2, n-2]): ${e}`);return e}));throw new TypeError("invalid bases option (must be an array)")}(s,j);null!=O?n=O.length:(null==n||n<1)&&(n=(P=I)>1e3?2:P>500?3:P>250?4:P>150?5:6);let x=!0,E=null,M=null,A=0;e:for(let t=0;t<n;t++){let n;if(null!=O)n=O[A],A++;else do{n=BigInt("0b"+l(I))}while(!(n>=g&&n<j));if(u){const t=o(e,n);if(t!==y){x=!1,E=n,M=t;break}}let t,r,i=p(a(n,T),S,T);if(i!==k&&i!==B){for(t=m;t<R;t++){if(r=c(i,T),r===k){x=!1,E=n,u&&(M=o(b(i,T)-y,e),M===y&&(M=null));break e}if(r===B)break;i=r}if(t===R){x=!1,E=n,u&&(M=o(b(i,T)-y,e),M===y&&(M=null));break}}}d(new PrimalityResult({n:w*e,probablePrime:x,witness:E,divisor:M}))}catch(e){w(e)}var P}))}return n})()));